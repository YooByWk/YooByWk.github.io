---
layout: post
title: "[Rust] 백준 1047 - 울타리 (N^4 브루트포스 + 그리디)"
subtitle: "N=40? 이 정도면 브루트포스 ㄹㅇ"
categories: [Rust, Algorithm]
tags: [Rust, Algorithm]
toc: true
date: 2025-10-10
series: "알고리즘"
banner: /assets/rustLogo.png
---

# 백준 1047 - 울타리

[문제](https://www.acmicpc.net/problem/1047)

## 문제 접근: 울타리의 네 모서리 찍기

> 근데 하나하나 다 찍어보기.

이 문제의 핵심은 **"최소 몇 그루를 베어야"** 울타리를 만들 수 있는지 찾는 것.

나무를 베면 재료가 생기고, 남아있는 나무들은 더 작은 직사각형을 만든다.

여기서 약간의 주의점이 있는데 단순히 재료가 긴 나무를 베는 그리디만 써서는 안됨. 직사각형의 크기 자체의 감소 + 적절한 나무를 자르는 전략이 필요.

하지만 하나하나 다 생각하기엔 머리아픔.

N = 40 이므로 다 자르자.

`N^4` 정도라면 가능하지 않을까? (4중 for 문)

~~그래도 혹시 불안해서 노드가 아닌 rust로 했다는건 비밀~~

따라서

일단 나무 4개를 "찍어서" (정말 하나하나 다 찍어보긴 함) 사각형을 만들고, (둘레 미리 고정)

외부의 나무를 다 잘라낸 다음, 부족하면 내부도 잘라보는 것.

"하나하나 찍어서 적어도 한번씩은 자르는 상상함"

정도로 요약될 수 있겠다.

### 접근 요약

1. **브루트포스** : 나무 하나하나 다 찍어서 사각형 만들기
2. 1번의 결과로 둘레 계산하기
3. 사각형 외부 나무는 다 자르기
4. 재료가 부족하다면 안에서 가장 많은 재료를 주는 나무 자르기.

## 구현

문제가 문제인만큼 조금 복잡하다.

### 메인과 구조체

약간의 자바 감성을 곁들인.

최대한 unwrap은 안쓰려고 했고,

함수 리턴도 확실하게 해두면 좋을 것 같아서 `Ok(())`를 쓰는 방향으로 진행해보았다.

익숙해지면 이게 더 깔끔할듯?

```rust
use std::io::{self, Read};

struct Tree {
    x: usize,
    y: usize,
    fence: usize,
}

pub fn solution() -> io::Result<()> {
    let mut input = String::new();
    io::stdin().read_to_string(&mut input)?;

    let mut tokens = input.split_ascii_whitespace();

    let n_str = tokens.next().expect("N값이 주어지지 않음");
    let n: usize = n_str.parse().expect("N 값이 유효한 숫자가 아님");

    let mut trees: Vec<Tree> = Vec::with_capacity(n);

    for _ in 0..n {
        let x: usize = tokens.next().unwrap().parse().unwrap();
        let y: usize = tokens.next().unwrap().parse().unwrap();
        let fence: usize = tokens.next().unwrap().parse().unwrap();

        trees.push(Tree { x, y, fence })
    }
    let min_cuts = bruteforce(n, &trees);
    println!("{}", min_cuts);
    Ok(())
}
```

### 벌목 계산

아래 주석에도 나와있지만...

모든 나무를 **댕강** 하는 경우가 최악의 경우이므로, 기본값으로 설정해두었다.

그 외에 설명할 내용은

사각형을 만드는데 필요한 나무는 4개 = for 문 4개. (가로 세로의 길이 중 하나가 0이어도 직사각형이며, 모두 0이어도 직사각형이다.) 라고 하니까.

`count_cuts()`는 다음에 나온다.

```rust
fn bruteforce(n: usize, trees: &[Tree]) -> usize {
    let mut min_cuts: usize = n; // 모든 나무를 댕강한 경우로 초기화

    for i in 0..n {
        for j in 0..n {
            for k in 0..n {
                for l in 0..n {
                    let min_x = trees[i].x;
                    let max_x = trees[j].x;
                    let min_y = trees[k].y;
                    let max_y = trees[l].y;

                    if min_x > max_x || min_y > max_y {
                        continue;
                    }

                    let cur_cuts = count_cuts(n, trees, min_x, max_x, min_y, max_y);
                    min_cuts = min_cuts.min(cur_cuts);
                } // l
            } // k
        } // j
    } // i
    min_cuts
}
```

### 브루트포스

여기가 사실상 메인 로직

1. 둘레를 구한다.
2. 내부 나무와 외부 나무로 구분한다.
3. 혹시 모르니 나중에 잘라야 하는 나무를 담아놓을 배열을 만든다.
4. 외부 나무를 자른다.
5. 부족하다면 내부 나무도 자른다. _단 재료를 많이 주는 순서대로._

`sort_unstable_by`를 사용한 이유 : 비안정 정렬 : 일반적으로 `sort()`보다 빠름. 동일요소의 원 순서는 중요하지 않다. 나무 자르고 카운트만 +1 하는 상황!

```rust
fn count_cuts(
    n: usize,
    trees: &[Tree],
    min_x: usize,
    max_x: usize,
    min_y: usize,
    max_y: usize,
) -> usize {
    let width = (max_x - min_x);
    let height = (max_y - min_y);
    let reqs = 2 * (width + height);

    let mut cur_cuts: usize = 0;
    let mut cur_material: usize = 0;
    let mut possible_cut_trees: Vec<usize> = Vec::new();

    for tree in trees.iter() {
        let is_inside = tree.x >= min_x && tree.x <= max_x && tree.y >= min_y && tree.y <= max_y;

        if is_inside {
            possible_cut_trees.push(tree.fence)
        } else {
            cur_cuts += 1;
            cur_material += tree.fence;
        }
    }
    // 충분하면 자른만큼 반환
    if cur_material >= reqs {
        return cur_cuts;
    }

    let mut falta = reqs - cur_material;

    possible_cut_trees.sort_unstable_by(|a, b| b.cmp(a));

    for material in possible_cut_trees.iter() {
        cur_cuts += 1;

        if *material >= falta { // <- 여기가 헷갈린 부분인데 & 보다 * 가 낫다고 한다. & (주소) vs * (값)
            return cur_cuts;
        } else {
            falta -= material;
        }
    }
    n // return n;
}


```

## 정답 코드

```rust

use std::io::{self, Read};

struct Tree {
    x: usize,
    y: usize,
    fence: usize,
}

pub fn solution() -> io::Result<()> {
    let mut input = String::new();
    io::stdin().read_to_string(&mut input)?;

    let mut tokens = input.split_ascii_whitespace();

    let n_str = tokens.next().expect("N값이 주어지지 않음");
    let n: usize = n_str.parse().expect("N 값이 유효한 숫자가 아님");

    let mut trees: Vec<Tree> = Vec::with_capacity(n);

    for _ in 0..n {
        let x: usize = tokens.next().unwrap().parse().unwrap();
        let y: usize = tokens.next().unwrap().parse().unwrap();
        let fence: usize = tokens.next().unwrap().parse().unwrap();

        trees.push(Tree { x, y, fence })
    }
    let min_cuts = bruteforce(n, &trees);
    println!("{}", min_cuts);
    Ok(())
}

fn bruteforce(n: usize, trees: &[Tree]) -> usize {
    let mut min_cuts: usize = n; // 모든 나무를 댕강한 경우로 초기화

    for i in 0..n {
        for j in 0..n {
            for k in 0..n {
                for l in 0..n {
                    let min_x = trees[i].x;
                    let max_x = trees[j].x;
                    let min_y = trees[k].y;
                    let max_y = trees[l].y;

                    if min_x > max_x || min_y > max_y {
                        continue;
                    }

                    let cur_cuts = count_cuts(n, trees, min_x, max_x, min_y, max_y);
                    min_cuts = min_cuts.min(cur_cuts);
                } // l
            } // k
        } // j
    } // i

    min_cuts
}

fn count_cuts(
    n: usize,
    trees: &[Tree],
    min_x: usize,
    max_x: usize,
    min_y: usize,
    max_y: usize,
) -> usize {
    let width = (max_x - min_x);
    let height = (max_y - min_y);
    let reqs = 2 * (width + height);

    let mut cur_cuts: usize = 0;
    let mut cur_material: usize = 0;
    let mut possible_cut_trees: Vec<usize> = Vec::new();

    for tree in trees.iter() {
        let is_inside = tree.x >= min_x && tree.x <= max_x && tree.y >= min_y && tree.y <= max_y;

        if is_inside {
            possible_cut_trees.push(tree.fence)
        } else {
            cur_cuts += 1;
            cur_material += tree.fence;
        }
    }
    // 충분하면 자른만큼 반환
    if cur_material >= reqs {
        return cur_cuts;
    }

    let mut falta = reqs - cur_material;

    possible_cut_trees.sort_unstable_by(|a, b| b.cmp(a));

    for material in possible_cut_trees.iter() {
        cur_cuts += 1;

        if *material >= falta {
            return cur_cuts;
        } else {
            falta -= material;
        }
    }
    n // return n;
}

```

## 후기 및 여담

혹시 몰라서 노드로 몇명 풀었나 봤는데...

3명이네... (이제 나까지 4명임 ㅎㅎ)

시간초과나 메모리 초과가 좀 흔한 문제인 것 같다.

러스트 잘 한 선택일지도?

아 그리고

`*` 사용 -> 메모리 주소가 아닌 주소의 실제 값 비교를 위한 것

이라고 한다.

음.

난 러스트 컴파일러 믿어.

잘하자.
